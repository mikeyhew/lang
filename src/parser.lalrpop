use crate::{
    ast::{Expr, Ident, Spanned},
};

grammar;

pub SpannedExpr: Spanned<Expr> = Spanned<Expr>;

Expr: Expr = {
    EmptyRecord,
    RecordValue,
    RecordType,
    Tuple,
    Block,
    Number,
    Var,
    "(" <Expr> ")",
}

EmptyRecord: Expr = {
    "{" "}" => Expr::EmptyRecord
}

RecordValue: Expr = {
    "{" <CommaAtLeast1<RecordFieldValue>> "}" => Expr::RecordValue(<>)
}

RecordFieldValue: (Spanned<Ident>, Spanned<Expr>) = {
    <name:Spanned<Ident>> "=" <value:Spanned<Expr>> => (name, value)
}

RecordType: Expr = {
    "{" <CommaAtLeast1<RecordFieldType>> "}" => Expr::RecordType(<>)
}

RecordFieldType: (Spanned<Ident>, Spanned<Expr>) = {
    <name:Spanned<Ident>> ":" <typ:Spanned<Expr>> => (name, typ)
}

Tuple: Expr = {
    "(" ")" => Expr::Tuple(Vec::new()),
    "(" <Spanned<Expr>> "," ")" => Expr::Tuple(vec![<>]),
    "(" <first:Spanned<Expr>> "," <rest:CommaAtLeast1<Spanned<Expr>>> ")" => {
        let mut all = vec![first];
        all.extend(rest);
        Expr::Tuple(all)
    }
}

Block: Expr = {
    "{" <first:Spanned<Expr>> <rest:( ";" <Spanned<Expr>> )*> <ending_semi:";"?> "}" => {
        let mut statement_exprs = vec![first];
        statement_exprs.extend(rest);

        let last = if ending_semi.is_none() {
            Some(Box::new(statement_exprs.pop().unwrap()))
        } else {
            None
        };

        Expr::Block(statement_exprs, last)
    }
}

Var: Expr = {
    Ident => Expr::Var(<>)
}

Number: Expr = {
    r"-?[0-9]+" => Expr::Number(<>.parse().unwrap()),
}

Ident: Ident = {
    r"[\pL_][\pL\pN_]*" => <>.into()
}

// Macros

Spanned<T>: Spanned<T> = {
    <start:@L> <value: T> <end:@R> => {
        Spanned::from_value_and_byte_offsets(value, start, end)
    }
}

Comma<Rule>: Vec<Rule> = {
    <rules:(<Rule> ",")*> <last:Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    }
}

CommaAtLeast1<Rule>: Vec<Rule> = {
    <first:Rule> <rest:("," <Rule>)*> ","? => {
        let mut rules = vec![first];
        rules.extend(rest);
        rules
    }
}
