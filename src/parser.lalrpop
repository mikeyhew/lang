use crate::{
    ast::{Expr, Ident, Spanned},
    util::unescape,
};

grammar;

pub SpannedExpr: Spanned<Expr> = Spanned<Expr>;

Expr: Expr = {
    Let,
    SmallExpr,
}

SmallExpr: Expr = {
    EmptyRecord,
    RecordValue,
    RecordType,
    Tuple,
    Block,
    NumberLiteral,
    StringLiteral,
    Var,
    RecordFieldAccess,
    TupleFieldAccess,
    "(" <Expr> ")",
}

EmptyRecord: Expr = {
    "{" "}" => Expr::EmptyRecord
}

RecordValue: Expr = {
    "{" <CommaAtLeast1<RecordFieldValue>> "}" => Expr::RecordValue(<>)
}

RecordFieldValue: (Spanned<Ident>, Spanned<Expr>) = {
    <name:Spanned<Ident>> "=" <value:Spanned<Expr>> => (name, value)
}

RecordType: Expr = {
    "{" <CommaAtLeast1<RecordFieldType>> "}" => Expr::RecordType(<>)
}

RecordFieldType: (Spanned<Ident>, Spanned<Expr>) = {
    <name:Spanned<Ident>> ":" <typ:Spanned<Expr>> => (name, typ)
}

Tuple: Expr = {
    "(" ")" => Expr::Tuple(Vec::new()),
    "(" <Spanned<Expr>> "," ")" => Expr::Tuple(vec![<>]),
    "(" <first:Spanned<Expr>> "," <rest:CommaAtLeast1<Spanned<Expr>>> ")" => {
        let mut all = vec![first];
        all.extend(rest);
        Expr::Tuple(all)
    }
}

Block: Expr = {
    "{" <first:Spanned<Expr>> <rest:( ";" <Spanned<Expr>> )*> <ending_semi:";"?> "}" => {
        let mut statement_exprs = vec![first];
        statement_exprs.extend(rest);

        let last = if ending_semi.is_none() {
            Some(Box::new(statement_exprs.pop().unwrap()))
        } else {
            None
        };

        Expr::Block(statement_exprs, last)
    }
}

Let: Expr = {
    "let" <name:Spanned<Ident>> "=" <value:Spanned<Expr>> "in" <body:Spanned<Expr>> => {
        Expr::Let(name, Box::new(value), Box::new(body))
    }
}

Var: Expr = {
    Ident => Expr::Var(<>)
}

RecordFieldAccess: Expr = {
    <expr:Spanned<SmallExpr>> "." <field_name:Ident> => Expr::RecordFieldAccess(Box::new(expr), field_name),
}

TupleFieldAccess: Expr = {
    <expr:Spanned<SmallExpr>> "." <field_number:Digits> => Expr::TupleFieldAccess(Box::new(expr), field_number),
}

Digits: usize = {
    r"[0-9]+" => <>.parse().expect("number too big"),
}

NumberLiteral: Expr = {
    <sign:"-"?> <digits:Digits> => {
        let digits = digits as isize;

        let number = if sign.is_some() {
            -digits
        } else {
            digits
        };

        Expr::NumberLiteral(number)
    }
}

StringLiteral: Expr = {
    r#""(\\.|[^\\"])*""# => {
        let s = <>[1..(<>.len() - 1)].into();

        Expr::StringLiteral(unescape(s))
    }
}

Ident: Ident = {
    r"[\pL_][\pL\pN_]*" => <>.into()
}

// Macros

Spanned<T>: Spanned<T> = {
    <start:@L> <value: T> <end:@R> => {
        Spanned::from_value_and_byte_offsets(value, start, end)
    }
}

Comma<Rule>: Vec<Rule> = {
    <rules:(<Rule> ",")*> <last:Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    }
}

CommaAtLeast1<Rule>: Vec<Rule> = {
    <first:Rule> <rest:("," <Rule>)*> ","? => {
        let mut rules = vec![first];
        rules.extend(rest);
        rules
    }
}
