use crate::{
    ast::{Expr, ExprKind, Ident, Span},
    util::unescape,
};
use std::{
    convert::TryInto,
};

grammar;

pub Expr: Expr = {
    Spanned<ExprKind> => Expr::new(<>),
}

ExprKind: ExprKind = {
    Let,
    SmallExprKind,
}

SmallExpr: Expr = {
    Spanned<SmallExprKind> => Expr::new(<>),
}

SmallExprKind: ExprKind = {
    EmptyRecord,
    RecordValue,
    RecordType,
    Tuple,
    Block,
    NumberLiteral,
    StringLiteral,
    Var,
    RecordFieldAccess,
    TupleFieldAccess,
    "(" <expr:Expr> ")" => {
        ExprKind::Parenthesized(Box::new(expr))
    }
}

EmptyRecord: ExprKind = {
    "{" "}" => ExprKind::EmptyRecord
}

RecordValue: ExprKind = {
    "{" <CommaAtLeast1<RecordFieldValue>> "}" => ExprKind::RecordValue(<>)
}

RecordFieldValue: (Ident, Expr) = {
    <name:Ident> "=" <value:Expr> => (name, value)
}

RecordType: ExprKind = {
    "{" <CommaAtLeast1<RecordFieldType>> "}" => ExprKind::RecordType(<>)
}

RecordFieldType: (Ident, Expr) = {
    <name:Ident> ":" <typ:Expr> => (name, typ)
}

Tuple: ExprKind = {
    "(" ")" => ExprKind::Tuple(Vec::new()),
    "(" <Expr> "," ")" => ExprKind::Tuple(vec![<>]),
    "(" <first:Expr> "," <rest:CommaAtLeast1<Expr>> ")" => {
        let mut all = vec![first];
        all.extend(rest);
        ExprKind::Tuple(all)
    }
}

Block: ExprKind = {
    "{" <first:Expr> <rest:( ";" <Expr> )*> <ending_semi:";"?> "}" => {
        let mut statement_exprs = vec![first];
        statement_exprs.extend(rest);

        let last = if ending_semi.is_none() {
            Some(Box::new(statement_exprs.pop().unwrap()))
        } else {
            None
        };

        ExprKind::Block(statement_exprs, last)
    }
}

Let: ExprKind = {
    "let" <name:Ident> "=" <value:Expr> "in" <body:Expr> => {
        ExprKind::Let(name, Box::new(value), Box::new(body))
    }
}

Var: ExprKind = {
    Ident => ExprKind::Var(<>)
}

RecordFieldAccess: ExprKind = {
    <expr:SmallExpr> "." <field_name:Ident> => ExprKind::RecordFieldAccess(Box::new(expr), field_name),
}

TupleFieldAccess: ExprKind = {
    <expr:SmallExpr> "." <field_number:Digits> => {
        ExprKind::TupleFieldAccess(Box::new(expr), field_number.try_into().expect("field number too big"))
    }
}

Digits: u64 = {
    r"[0-9]+" => <>.parse().expect("number too big"),
}

NumberLiteral: ExprKind = {
    <sign:"-"?> <digits:Digits> => {
        let digits = digits as i64;

        let number = if sign.is_some() {
            -digits
        } else {
            digits
        };

        ExprKind::NumberLiteral(number.into())
    }
}

StringLiteral: ExprKind = {
    r#""(\\.|[^\\"])*""# => {
        let s = <>[1..(<>.len() - 1)].into();

        ExprKind::StringLiteral(unescape(s))
    }
}

Ident: Ident = {
    Spanned<r"[\pL_][\pL\pN_]*"> => {
        let (name, span) = <>;

        Ident::new(name, span)
    }
}

// Macros

Spanned<T>: (T, Span) = {
    <start:@L> <value: T> <end:@R> => {
        let span = Span::from_byte_offsets(start, end);

        (value, span)
    }
}

Comma<Rule>: Vec<Rule> = {
    <rules:(<Rule> ",")*> <last:Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    }
}

CommaAtLeast1<Rule>: Vec<Rule> = {
    <first:Rule> <rest:("," <Rule>)*> ","? => {
        let mut rules = vec![first];
        rules.extend(rest);
        rules
    }
}
