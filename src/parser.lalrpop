use crate::{
    ast::{
        Expr, ExprKind,
        Stmt, StmtKind,
        ReplLine, ReplLineKind,
        Ident,
        Span,
    },
    util::unescape,
};
use std::{
    convert::TryInto,
};

grammar;

pub ReplLine: ReplLine = {
    Spanned<ReplLineKind> => {
        let (kind, span) = <>;
        ReplLine {kind, span}
    }
}

ReplLineKind: ReplLineKind = {
    <stmts:(<Stmt> ";")*> <expr:Expr?> => ReplLineKind::Block(stmts, expr),
}

Expr: Expr = {
    Spanned<ExprKind> => Expr::new(<>),
}

ExprKind: ExprKind = {
    SmallExprKind,
}

SmallExpr: Expr = {
    Spanned<SmallExprKind> => Expr::new(<>),
}

SmallExprKind: ExprKind = {
    EmptyRecord,
    EmptyRecordType,
    RecordValue,
    RecordType,
    RecordFieldAccess,
    EmptyTuple,
    EmptyTupleType,
    TupleFieldAccess,
    Tuple,
    Block,
    NumberLiteral,
    StringLiteral,
    Var,
    "(" <expr:Expr> ")" => {
        ExprKind::Parenthesized(Box::new(expr))
    }
}

Stmt: Stmt = {
    Spanned<StmtKind> => Stmt::new(<>),
}

StmtKind: StmtKind = {
    Let,
}

EmptyRecord: ExprKind = {
    "{" "}" => ExprKind::Nil,
}

EmptyRecordType: ExprKind = {
    "type" "{" "}" => ExprKind::NilType,
}

RecordValue: ExprKind = {
    "{" <CommaAtLeast1<RecordFieldValue>> "}" => ExprKind::RecordValue(<>)
}

RecordFieldValue: (Ident, Expr) = {
    <name:Ident> "=" <value:Expr> => (name, value)
}

RecordType: ExprKind = {
    "{" <CommaAtLeast1<RecordFieldType>> "}" => ExprKind::RecordType(<>)
}

RecordFieldType: (Ident, Expr) = {
    <name:Ident> ":" <typ:Expr> => (name, typ)
}

RecordFieldAccess: ExprKind = {
    <expr:SmallExpr> "." <field_name:Ident> => ExprKind::RecordFieldAccess(Box::new(expr), field_name),
}

EmptyTuple: ExprKind = {
    "(" ")" => ExprKind::Nil,
}

EmptyTupleType: ExprKind = {
    "type" "(" ")" => ExprKind::NilType,
}

Tuple: ExprKind = {
    "(" <elems:CommaAtLeast2<Expr>> ")" => ExprKind::Tuple(elems),
}

TupleType: ExprKind = {
    "type" "(" <elems:CommaAtLeast2<Expr>> ")" => ExprKind::TupleType(elems),
}

TupleFieldAccess: ExprKind = {
    <expr:SmallExpr> "." <field_number:Digits> => {
        ExprKind::TupleFieldAccess(Box::new(expr), field_number.try_into().expect("field number too big"))
    }
}

Block: ExprKind = {
    "{" <expr:Expr> "}" => ExprKind::Block(Vec::new(), Some(Box::new(expr))),
    "{" <stmts:(<Stmt> ";")+> <expr:Expr?> "}" => ExprKind::Block(stmts, expr.map(Box::new)),
}

Let: StmtKind = {
    "let" <name:Ident> "=" <value:Expr> => {
        StmtKind::Let(name, Box::new(value))
    }
}

Var: ExprKind = {
    Ident => ExprKind::Var(<>)
}

Digits: u64 = {
    r"[0-9]+" => <>.parse().expect("number too big"),
}

NumberLiteral: ExprKind = {
    <sign:"-"?> <digits:Digits> => {
        let digits = digits as i64;

        let number = if sign.is_some() {
            -digits
        } else {
            digits
        };

        ExprKind::NumberLiteral(number.into())
    }
}

StringLiteral: ExprKind = {
    r#""(\\.|[^\\"])*""# => {
        let s = <>[1..(<>.len() - 1)].into();

        ExprKind::StringLiteral(unescape(s))
    }
}

Ident: Ident = {
    Spanned<r"[\pL_][\pL\pN_]*"> => {
        let (name, span) = <>;

        Ident::new(name, span)
    }
}

// Macros

Spanned<T>: (T, Span) = {
    <start:@L> <value: T> <end:@R> => {
        let span = Span::from_byte_offsets(start, end);

        (value, span)
    }
}

Comma<Rule>: Vec<Rule> = {
    <rules:(<Rule> ",")*> <last:Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    }
}

CommaAtLeast1<Rule>: Vec<Rule> = {
    <first:Rule> <rest:("," <Rule>)*> ","? => {
        let mut rules = vec![first];
        rules.extend(rest);
        rules
    }
}

CommaAtLeast2<Rule>: Vec<Rule> = {
    <first:Rule> "," <rest:CommaAtLeast1<Rule>> => {
        let mut rules = vec![first];
        rules.extend(rest);
        rules
    }
}
